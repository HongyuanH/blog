---
layout:            post
title:             "Modern C++ Tutorials, Notes #3"
date:              2023-05-22
tags:              CPP
category:          Modern CPP
author:            hongyuan

---

## 03 Language Runtime Enhancement

### std::bind and std::placeholder

```cpp
int foo(int a, int b, int c) {
    return a * b + c;
}

int main() {
    auto bindFoo = bind(foo, placeholders::_1, 1, 2);
    cout << bindFoo(1) << endl;
}
```

### lvalue, rvalue, prvalue, xrvalue

* lvalue, left value, as the name implies, is the value to the left of the assignment symbol. To be precise, an lvalue is a persistent object that still exists after an expression (not necessarily an assignment expression).
* rvalue, right value, the value on the right refers to the temporary object that no longer exists after the expression ends.
* pvalue, pure rvalue, purely rvalue, either purely literal, such as `10`, `true`; either the result of the evaluation is equivalent to a literal or anonymous temporary object, for example `1+2`. Temporary variables returned by non-references, temporary variables generated by operation expressions, original literals, and Lambda expressions are all pure rvalue values.
* xvalue, expiring value is the concept proposed by C++11 to introduce rvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts), a value that is destroyed but can be moved.

### rvalue reference and lvalue reference

* lvalue ref can't bind to rvalue
* const lvalue ref can bind to rvalue, it extends the lifetime of the temporary object and the object can't be modified
* rvalue ref can bind to rvalue, it extends the lifetime of the temporary object and the object can be modified

Why not allow non-constant references to bind to non-lvalues? This is because there is a logic error in this approach:

```cpp
void increase(int & v) {
    v++;
}
void foo() {
    double s = 1;
    increase(s); // s is converted to a temp int object, modifying the temp object won't change s
}
```

Why do constant references allow binding to non-lvalues? The reason is simple because Fortran needs it.

Some brain teasers:

```cpp
int sourceArray[5] = {1, 2, 3, 4, 5};
int* destinationArray = move(sourceArray); // same as static_cast<int*>(sourceArray)
sourceArray[0] = 10;
cout << destinationArray[0] << endl;       // 10
```

```cpp
/* Note that a literal (except a string literal) is a prvalue. 
 * However, a string literal is an lvalue with type const char array. 
 */
// Assert success. It is a const char [6] indeed. Note that decltype(expr)
// yields lvalue reference if expr is an lvalue and neither an unparenthesized
// id-expression nor an unparenthesized class member access expression.
static_assert(std::is_same<decltype("01234"), const char(&)[6]>::value, "");
 
// Correct. The type of "01234" is const char [6], so it is an lvalue
const char (&left)[6] = "01234";
// Error. "01234" is an lvalue, which cannot be referenced by an rvalue reference
// const char (&&right)[6] = "01234";
// Correct. std::move unconditionally convert lvalue to rvalue
const char (&&right)[6] = std::move("01234");

/* However, an array can be implicitly converted to a corresponding pointer.
 * The result, if not an lvalue reference, is an rvalue (xvalue if the result is an rvalue reference, prvalue otherwise)
 */
const char*   p      = "01234";   // Correct. "01234" is implicitly converted to const char*
const char* (&&pr)   = "01234";   // Correct. "01234" is implicitly converted to const char*, which is a prvalue
// const char* (&pl) = "01234";   // Error: lvalue can't ref to temp variable 
const char* const (&pl) = "1234"; // Correct: const lvalue reference can extend temp variable's lifecycle
```

```cpp
void reference(string& str) {
    cout << "lvalue" << endl;
}
void reference(string&& str) {
    cout << "rvalue" << endl;
}

int main()
{
    string  lv1 = "string,";       // lv1 is a lvalue
    // string&& r1 = lv1;          // illegal, rvalue can't ref to lvalue
    string&& rv1 = move(lv1);      // legal, move can convert lvalue to rvalue
    cout << rv1 << endl;           // string,

    // string& l2 = lv1 + lv1;     // illegal, lvalue can't ref to temp variable 
                                   // (lv1 + lv1) is a temp variable

    const string& lv2 = lv1 + lv1; // legal, const lvalue reference can
                                   // extend temp variable's lifecycle
    // lv2 += "Test";              // illegal, const ref can't be modified
    cout << lv2 << endl;           // string,string,

    string&& rv2 = lv1 + lv2;      // legal, rvalue ref extend lifecycle
    rv2 += "string";               // legal, non-const reference can be modified
    cout << rv2 << endl;           // string,string,string,string

    reference(rv2);                // output: lvalue

    return 0;
}
```
