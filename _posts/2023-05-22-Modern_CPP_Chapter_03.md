---
layout:            post
title:             "Modern C++ Tutorials, Notes #3"
date:              2023-05-22
tags:              CPP
category:          Modern CPP
author:            hongyuan

---

## 03 Language Runtime Enhancement

### std::bind and std::placeholder

```cpp
int foo(int a, int b, int c) {
    return a * b + c;
}

int main() {
    auto bindFoo = bind(foo, placeholders::_1, 1, 2);
    cout << bindFoo(1) << endl;
}
```

### lvalue, rvalue, prvalue, xrvalue

* lvalue, left value, as the name implies, is the value to the left of the assignment symbol. To be precise, an lvalue is a persistent object that still exists after an expression (not necessarily an assignment expression).
* rvalue, right value, the value on the right refers to the temporary object that no longer exists after the expression ends.
* pvalue, pure rvalue, purely rvalue, either purely literal, such as `10`, `true`; either the result of the evaluation is equivalent to a literal or anonymous temporary object, for example `1+2`. Temporary variables returned by non-references, temporary variables generated by operation expressions, original literals, and Lambda expressions are all pure rvalue values.
* xvalue, expiring value is the concept proposed by C++11 to introduce rvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts), a value that is destroyed but can be moved.

```cpp
/* Note that a literal (except a string literal) is a prvalue. 
 * However, a string literal is an lvalue with type const char array. 
 */
// Correct. The type of "01234" is const char [6], so it is an lvalue
const char (&left)[6] = "01234";
// Assert success. It is a const char [6] indeed. Note that decltype(expr)
// yields lvalue reference if expr is an lvalue and neither an unparenthesized
// id-expression nor an unparenthesized class member access expression.
static_assert(std::is_same<decltype("01234"), const char(&)[6]>::value, "");
// Error. "01234" is an lvalue, which cannot be referenced by an rvalue reference
// const char (&&right)[6] = "01234";

/* However, an array can be implicitly converted to a corresponding pointer.
 * The result, if not an lvalue reference, is an rvalue (xvalue if the result is an rvalue reference, prvalue otherwise)
 */
const char*   p    = "01234"; // Correct. "01234" is implicitly converted to const char*
const char*&& pr   = "01234"; // Correct. "01234" is implicitly converted to const char*, which is a prvalue.
// const char*& pl = "01234"; // Error. There is no type const char* lvalue
```
